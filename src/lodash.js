'use strict'

module.exports = {
  assign: assign,
  find: find,
  remove: remove,
  isArray: isArray,
  isObject: isObject,
  isBoolean: isBoolean,
  isString: isString,
  isNumber: isNumber,
  isFunction: isFunction,
  get: get,
  set: set,
  map: map,
  keys: keys,
  sortBy: sortBy,
  forEach: forEach,
  isUndefined: isUndefined,
  pick: pick,
  xor: xor,
  clone: clone,
  isEqual: isEqual,
  replaceArray: replaceArray,
  uniq: uniq,
  flatten: flatten,
  sort: sort,
  values: values,
  recurseObject: recurseObject,
}


function assign(out) {
  out = out || {}
  for (var i = 1; i < arguments.length; i++) {
    if (!arguments[i])
      continue;
    for (var key in arguments[i]) {
      if (arguments[i].hasOwnProperty(key))
        out[key] = arguments[i][key]
    }
  }
  return out
}

function find(a, b) {
  return a.find(b);
}

function remove(a, b) {
  return a.filter(function(o, i) {
    var r = b(o)
    if (r) {
      a.splice(i, 1)
      return true
    }
  })
}

function isArray(a) {
  return Array.isArray(a)
}

function isObject(d) {
  return typeof(d) === 'object' && !isArray(d)
}

function isBoolean(d) {
  return typeof(d) === 'boolean'
}

function isString(d) {
  return typeof(d) === 'string'
}

function isNumber(d) {
  return typeof(d) === 'number'
}

function isFunction(a) {
  return typeof(a) === 'function'
}

function get(a, b) {
  if (isArray(b)) {
    b = b.join('.')
  }
  return b
    .replace('[', '.').replace(']', '')
    .split('.')
    .reduce(
      function(obj, property) {
        return obj[property];
      }, a
    )
}

function set(obj, prop, value) {
  if (typeof prop === "string") {
    prop = prop
      .replace('[', '.').replace(']', '')
      .split(".")
  }
  if (prop.length > 1) {
    var e = prop.shift()
    assign(obj[e] =
      Object.prototype.toString.call(obj[e]) === "[object Object]" ? obj[e] : {},
      prop,
      value)
  } else {
    obj[prop[0]] = value
  }
}

function map(a, b) {
  var m
  var key
  if (isFunction(b)) {
    if (isObject(a)) {
      m = []
      for (key in a) {
        if (a.hasOwnProperty(key)) {
          m.push(b(a[key], key, a))
        }
      }
      return m
    }
    return a.map(b)
  }
  if (isObject(a)) {
    m = []
    for (key in a) {
      if (a.hasOwnProperty(key)) {
        m.push(a[key])
      }
    }
    return m
  }
  return a.map(function(aa, i) {
    return aa[b]
  })
}

function keys(obj) {
  return Object.keys(obj)
}

function sortBy(a, b) {
  if (isFunction(b)) {
    return a.sort(function(aa, bb) {
      if (b(aa) > b(bb)) {
        return 1;
      }
      if (b(aa) < b(bb)) {
        return -1;
      }
      // a must be equal to b
      return 0;
    });
  }
}

function forEach(a, b) {
  if (isObject(a)) {
    for (var key in a) {
      if (a.hasOwnProperty(key)) {
        b(a[key], key, a)
      }
    }
    return
  }
  if (isArray(a)) {
    return a.forEach(b)
  }
}

function isUndefined(a) {
  return typeof(a) === 'undefined'
}

function pick(a, b) {
  var c = {}
  forEach(b, function(bb) {
    if (typeof(a[bb]) !== 'undefined') c[bb] = a[bb]
  })
  return c
}

function xor(a, b) {

  var unique = []
  forEach(a, function(aa) {
    if (b.indexOf(aa) === -1) {
      return unique.push(aa)
    }
  })
  forEach(b, function(bb) {
    if (a.indexOf(bb) === -1) {
      return unique.push(bb)
    }
  })
  return unique
}

function clone(a) {
  return JSON.parse(JSON.stringify(a, function replacer(key, value) {
    if (typeof value === "function") {
      return value.toString();
    }
    return value;
  }))
}

function isEqual(x, y) {
  if ((typeof x == "object" && x !== null) && (typeof y == "object" && y !== null)) {
    if (Object.keys(x).length != Object.keys(y).length)
      return false;

    for (var prop in x) {
      if (y.hasOwnProperty(prop)) {
        if (!isEqual(x[prop], y[prop]))
          return false;
      } else
        return false;
    }

    return true;
  } else if (x !== y)
    return false;
  else
    return true;
}

function replaceArray(a, b) {
  var al = a.length
  var bl = b.length
  if (al > bl) {
    a.splice(bl, al - bl)
  } else if (al < bl) {
    a.push.apply(a, new Array(bl - al))
  }
  forEach(a, function(val, key) {
    a[key] = b[key]
  })
  return a
}

function uniq(a) {
  var seen = new Set();
  return a.filter(function(item) {
    var allow = false;
    if (!seen.has(item)) {
      seen.add(item);
      allow = true;
    }
    return allow;
  })
}

function flatten(aa) {
  var flattened = [];
  for (var i = 0; i < aa.length; ++i) {
    var current = aa[i];
    for (var j = 0; j < current.length; ++j)
      flattened.push(current[j]);
  }
  return flattened
}

function sort(arr) {
  for (var i = 1; i < arr.length; i++) {
    var tmp = arr[i],
      j = i;
    while (arr[j - 1] > tmp) {
      arr[j] = arr[j - 1];
      --j;
    }
    arr[j] = tmp;
  }

  return arr;
}

function values(a) {
  var values = []
  for (var key in a) {
    if (a.hasOwnProperty(key)) {
      values.push(a[key])
    }
  }
  return values
}

function recurseObject(obj, cb) {
  _recurseObject(obj, [])
  return obj
  function _recurseObject(obj, path) {
    for (var k in obj) {
      var newPath = clone(path)
      newPath.push(k)
      if (typeof obj[k] == "object" && obj[k] !== null) {
        _recurseObject(obj[k], newPath)
      } else {
        if (!obj.hasOwnProperty(k)) {
          continue
        }
        cb(obj[k], k, newPath)
      }
    }
  }
}
